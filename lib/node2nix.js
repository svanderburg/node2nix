var fs = require('fs');
var path = require('path');
var slasp = require('slasp');
var nijs = require('nijs');
const yarn_wrapper = require("../node_modules/yarn/lib/lockfile/wrapper");
var PackageSet = require('./packageset.js').PackageSet;
var packageGenerator = require('./generator/package.js');
var collectionGenerator = require('./generator/collection.js');
var compositionGenerator = require('./generator/composition.js');

/**
 * @member node2nix
 *
 * Writes a copy of node-env.nix to a specified path.
 *
 * @param {String} nodeEnvNix Path to which the NPM package build expression is written
 * @param {function(String)} callback Callback function that gets invoked if the operation is done.
 *     If an error has occured, the error parameter is set to the error message.
 */
function copyNodeEnvExpr(nodeEnvNix, callback) {
    /* Compose a read stream that reads the build expression */
    var rs = fs.createReadStream(path.join(path.dirname(module.filename), "..", "nix", "node-env.nix"));
    rs.on("error", function(err) {
        callback(err);
    });
    
    /* Compose a write stream that writes the build expression */
    var ws = fs.createWriteStream(nodeEnvNix);
    ws.on("error", function(err) {
        callback(err);
    });
    ws.on("close", function() {
        callback(null);
    });
    
    /* Pipe the data to actually copy stuff */
    rs.pipe(ws);
}

exports.copyNodeEnvExpr = copyNodeEnvExpr;

/**
 * @member node2nix
 *
 * Generates a Nix expression from a JSON file representing a Node.js package
 * configuration or an array of NPM dependencies.
 *
 * @param {String} inputJSON Path to a package.json or arbitrary JSON file
 * @param {String} yarnDir Path to directory containing the yarn.lock file. May be undefined.
 * @param {String} outputNix Path to which the generated registry expression is written
 * @param {String} compositionNix Path to which the generated composition expression is written
 * @param {String} nodeEnvNix Path to which the NPM package build expression is written
 * @param {String} supplementJSON Path to a supplement JSON file
 * @param {String} supplementNix Path to which the generated supplement expression is written
 * @param {Boolean} production Indicates whether to deploy the package in production mode
 * @param {Boolean} includePeerDependencies Indicates whether to include peer dependencies with the package
 * @param {Boolean} flatten Indicates whether to create a flat dependency structure in which dependencies are as high as possible in the graph
 * @param {String} nodePackage Name of the Node.js package to use from Nixpkgs
 * @param {String} registryURL URL of the NPM registry
 * @param {function(String, String)} callback Callback function that gets invoked when the work is done.
 *     If an error occurs, the error parameter is set to contain the error
 *     If the operation succeeds, it returns a string containing the registry expression containing the packages and all its dependencies
 */
function npmToNix(inputJSON, yarnDir, outputNix, compositionNix, nodeEnvNix, supplementJSON, supplementNix, production, includePeerDependencies, flatten, nodePackage, registryURL, callback) {
    var obj = JSON.parse(fs.readFileSync(inputJSON));
    var version = JSON.parse(fs.readFileSync(path.join(__dirname, "..", "package.json"))).version;
    var disclaimer = "# This file has been generated by node2nix " + version + ". Do not edit!\n\n";
    var outputDir = path.dirname(outputNix);
    var baseDir = path.dirname(inputJSON);
    var packageSet = new PackageSet(registryURL, outputDir);
    
    slasp.sequence([
        /* Compute yarn info from lockfile */
        function (callback) {
          if (typeof yarnDir == "undefined") {
            callback(null, undefined);
          } else {
            yarn_wrapper.default.fromDirectory(yarnDir).then((lockfile) => {
             if (!lockfile.cache) {
                throw "yarn.lock could not be found or loaded";
              }
              callback(null, lockfile.cache);
            }).catch((err) => {
              callback(err);
            });
          }
        },
        /* Generate a Nix expression */
        function(callback, yarnInfo) {
            if(typeof obj == "object" && obj !== null) {
                if(Array.isArray(obj)) {
                    collectionGenerator.generateCollectionExpr(packageSet, obj, yarnInfo, baseDir, production, includePeerDependencies, flatten, callback);
                } else {
                    packageGenerator.generatePackageExpr(packageSet, obj, yarnInfo, baseDir, new nijs.NixFile({ value: "./." }), production, includePeerDependencies, flatten, callback);
                }
            } else {
                callback("The provided JSON file must consist of an object or an array");
            }
        },
        
        /* Write the output Nix expression to the specified output file */
        function(callback, expr) {
            fs.writeFile(outputNix, disclaimer + nijs.jsToNix(expr, true), callback);
        },
        
        function(callback) {
            /* Generate the supplement Nix expression, if specified */
            if(supplementJSON) {
                var obj = JSON.parse(fs.readFileSync(supplementJSON));
                
                if(Array.isArray(obj)) {
                    collectionGenerator.generateCollectionExpr(packageSet, obj, baseDir, true, includePeerDependencies, flatten, callback);
                } else {
                    callback("The supplement JSON file should be an array");
                }
            } else {
                callback();
            }
        },
        
        function(callback, expr) {
            if(expr === undefined) {
                callback();
            } else {
                /* Write the supplement Nix expression to the specified output file */
                fs.writeFile(supplementNix, disclaimer + nijs.jsToNix(expr, true), callback);
            }
        },
        
        /* Copy the node-env.nix expression */
        function(callback) {
            fs.exists(nodeEnvNix, function(exists) { // Only copy the composition expression if it does not exists
                if(exists) {
                    callback();
                } else {
                    copyNodeEnvExpr(nodeEnvNix, callback);
                }
            });
        },
        
        /* Generate and write a Nix composition expression to the specified output file */
        function(callback) {
            var compositionExpr = compositionGenerator.generateCompositionExpr(nodeEnvNix, nodePackage, outputNix, supplementNix, (supplementJSON !== undefined));
            fs.writeFile(compositionNix, disclaimer + nijs.jsToNix(compositionExpr, true), callback);
        }
    ], callback);
}

exports.npmToNix = npmToNix;
